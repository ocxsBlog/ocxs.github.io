<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>OpenCV 学习笔记(2) Manipulating the Pixels (下) | Ocxs&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本节导读：


Writing effcient image scanning loops(编写高效的图像遍历循环)
Scanning an image with neighbor access(遍历图像和邻域操作)
Performing simple image arithmetic 
Defining regions of interest">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV 学习笔记(2) Manipulating the Pixels (下)">
<meta property="og:url" content="site:ocxsBlog.github.io/2015/10/26/151026-OpenCV-Manipulating-the-pixels-2/index.html">
<meta property="og:site_name" content="Ocxs's blog">
<meta property="og:description" content="本节导读：


Writing effcient image scanning loops(编写高效的图像遍历循环)
Scanning an image with neighbor access(遍历图像和邻域操作)
Performing simple image arithmetic 
Defining regions of interest">
<meta property="og:updated_time" content="2015-11-24T02:12:54.942Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenCV 学习笔记(2) Manipulating the Pixels (下)">
<meta name="twitter:description" content="本节导读：


Writing effcient image scanning loops(编写高效的图像遍历循环)
Scanning an image with neighbor access(遍历图像和邻域操作)
Performing simple image arithmetic 
Defining regions of interest">
  
    <link rel="alternative" href="/atom.xml" title="Ocxs&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ocxs</a></h1>
		</hgroup>

		
		<p class="header-subtitle">To be better</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Computer-Vision/" style="font-size: 15px;">Computer Vision</a> <a href="/tags/OpenCV/" style="font-size: 15px;">OpenCV</a> <a href="/tags/PAT/" style="font-size: 20px;">PAT</a> <a href="/tags/PAT-data-structure/" style="font-size: 20px;">PAT data structure</a> <a href="/tags/data-structure/" style="font-size: 10px;">data structure</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Computer Vision.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ocxs</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/avatar.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">ocxs</h1>
			</hgroup>
			
			<p class="header-subtitle">To be better</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-151026-OpenCV-Manipulating-the-pixels-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/26/151026-OpenCV-Manipulating-the-pixels-2/" class="article-date">
  	<time datetime="2015-10-26T13:17:43.000Z" itemprop="datePublished">2015-10-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      OpenCV 学习笔记(2) Manipulating the Pixels (下)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Vision/">Computer Vision</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenCV/">OpenCV</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  <!-- Table of Contents -->
	
	  <div id="toc" class="toc-article">
		<strong class="toc-title">Table of Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Writing_effcient_image_scanning_loops"><span class="toc-number">1.</span> <span class="toc-text">Writing effcient image scanning loops</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现方法"><span class="toc-number">1.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenMP_and_TBB"><span class="toc-number">1.2.</span> <span class="toc-text">OpenMP and TBB</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Scanning_an_image_with_neighbor_access"><span class="toc-number">2.</span> <span class="toc-text">Scanning an image with neighbor access</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原始的指针操作"><span class="toc-number">2.1.</span> <span class="toc-text">原始的指针操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用filter2D_method"><span class="toc-number">2.2.</span> <span class="toc-text">使用filter2D method</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Performing_simple_image_arithmetic"><span class="toc-number">3.</span> <span class="toc-text">Performing simple image arithmetic</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单的运算"><span class="toc-number">3.1.</span> <span class="toc-text">简单的运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Overloaded_image_operators"><span class="toc-number">3.2.</span> <span class="toc-text">Overloaded image operators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Splitting_the_image_channels"><span class="toc-number">3.3.</span> <span class="toc-text">Splitting the image channels</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Defining_regions_of_interest"><span class="toc-number">4.</span> <span class="toc-text">Defining regions of interest</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现方法-1"><span class="toc-number">4.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义ROI的方法"><span class="toc-number">4.2.</span> <span class="toc-text">定义ROI的方法</span></a></li></ol></li></ol>
	  </div>
	
	
        <p>本节导读：</p>
<blockquote>
<ul>
<li>Writing effcient image scanning loops(编写高效的图像遍历循环)</li>
<li>Scanning an image with neighbor access(遍历图像和邻域操作)</li>
<li>Performing simple image arithmetic </li>
<li>Defining regions of interest<a id="more"></a>
</li>
</ul>
</blockquote>
<h1 id="Writing_effcient_image_scanning_loops"><strong>Writing effcient image scanning loops</strong></h1><p>　　除非必要，否则不能以降低代码清晰度的代价去提升性能，简单的代码易维护和调试。</p>
<h2 id="实现方法"><strong>实现方法</strong></h2><p>　　实现方法在上一节里都写得差不多了，这一块主要是做对比分析，如图所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Average time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">data[i]= data[i]/div*div + div/2;</td>
<td style="text-align:center">37ms</td>
</tr>
<tr>
<td style="text-align:center">*data++= *data/div*div + div/2;</td>
<td style="text-align:center">37ms</td>
</tr>
<tr>
<td style="text-align:center">*data++= v - v%div + div/2;</td>
<td style="text-align:center">52ms</td>
</tr>
<tr>
<td style="text-align:center">*data++= *data&amp;mask + div/2;</td>
<td style="text-align:center">35ms</td>
</tr>
<tr>
<td style="text-align:center">colorReduce(input, output);</td>
<td style="text-align:center">44ms</td>
</tr>
<tr>
<td style="text-align:center">i&lt;image.cols*image.channels();</td>
<td style="text-align:center">65ms</td>
</tr>
<tr>
<td style="text-align:center">MatIterator</td>
<td style="text-align:center">67ms</td>
</tr>
<tr>
<td style="text-align:center">.at(j,i)</td>
<td style="text-align:center">80ms</td>
</tr>
<tr>
<td style="text-align:center">3-channel loop</td>
<td style="text-align:center">29ms</td>
</tr>
</tbody>
</table>
<p>　　这里书上介绍了两个函数，<code>cv::getTickCount()</code>和<code>cv::getTickFrequency()</code>;用法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> duration;</span><br><span class="line">duration = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(cv::getTickCount());</span><br><span class="line">colorReduce(image); <span class="comment">// the function to be tested</span></span><br><span class="line">duration = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(cv::getTickCount())-duration;</span><br><span class="line">duration /= cv::getTickFrequency(); <span class="comment">// the elapsed time in ms</span></span><br></pre></td></tr></table></figure></p>
<p>　　不得不说代码写的还真规范，要是我这样的渣写，肯定就不会想到用<code>static_cast&lt;double&gt;</code>来强制转换，直接<code>(double)</code>;从上面的表格中可以看出，用指针遍历快，迭代器遍历慢。<code>at</code>最慢，不过<code>at</code>的设计是用来随机存取像素值的，不适用遍历整幅图像。<br>　　迭代器的设计目标就是简化图像遍历的过程从而降低出错的机会，所以如果遍历整幅图像还是用指针，快，作为程序员，应该有避免错误的能力。</p>
<p>　　下面介绍一下书上提到的一些<strong>优化细节</strong>:</p>
<ul>
<li><strong>能提前计算的都提前计算出来</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nc= image.cols * image.channels();</span><br><span class="line">…</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nc; i++) &#123;</span><br></pre></td></tr></table></figure>
<p>来替换<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;image.cols * image.channels(); i++) &#123;</span><br></pre></td></tr></table></figure></p>
<p>　　这样就不用每次都要来计算<code>image.channels()</code>，重复计算有耗时，应丢弃，提前计算好用局部变量存储起来。</p>
<ul>
<li><strong>能在一个循环里解决的就不要在折腾</strong></li>
</ul>
<p>　　比如在处理三通道图像时，之前的代码中，内层循环有是这么设计的，使循环次数为<code>image.cols * image.channels()</code>，书上就说了，我们可以使循环次数变成<code>image.cols</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">colorReduce</span><span class="params">(cv::Mat &amp;image, <span class="keyword">int</span> div=<span class="number">64</span>)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nl= image.rows; <span class="comment">// number of lines</span></span><br><span class="line">	<span class="keyword">int</span> nc= image.cols ; <span class="comment">// number of columns</span></span><br><span class="line">	<span class="comment">// is it a continous image?</span></span><br><span class="line">	<span class="keyword">if</span> (image.isContinuous()) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// then no padded pixels</span></span><br><span class="line">		nc= nc*nl;</span><br><span class="line">		nl= <span class="number">1</span>; <span class="comment">// it is now a 1D array</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nl; j++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// pointer to first column of line j</span></span><br><span class="line">		uchar* data= image.ptr&lt;uchar&gt;(j);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nc; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			*data++= div/<span class="number">2</span>;	<span class="comment">//data[i][0]</span></span><br><span class="line">			*data++= div/<span class="number">2</span>;	<span class="comment">//data[i][1]</span></span><br><span class="line">			*data++= div/<span class="number">2</span>;	<span class="comment">//data[i][2]</span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　上面这段代码，按照书上的意思是<strong>最快的图像遍历</strong>方法了！(如果我没理解错的话，有错欢迎指正！)</p>
<h2 id="OpenMP_and_TBB"><strong>OpenMP and TBB</strong></h2><p>　　多线程处理是另外一个提升算法效率的方式，OpenMP 与 Intel Threading Building Blocks(TBB)是两个比较流行的并行编程API。VS2013里有可以直接用OpenMP，具体用法搜索一下，我用过，基础的操作还是蛮简单的，看一下就会用了，奈何自己笔记本就两核，只提升了2倍。</p>
<hr>
<h1 id="Scanning_an_image_with_neighbor_access"><strong>Scanning an image with neighbor access</strong></h1><p>　　与其说这一节教你怎么进行邻域操作，倒不如说教你怎么进行图像锐化，一共两种方法，第一种原始的指针操作，第二种自定义核算子，利用OpenCV函数<code>filter2D</code>来操作，更加快捷，二者结果一样，甚至核的尺寸如果比较大，后者效率更高。<br>锐化算子的计算方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sharpened_pixel= <span class="number">5</span> * current - left - right - up - down;</span><br><span class="line"><span class="comment">//current代表当前像素值，left代表当前像素位置左边的像素值，依次类推</span></span><br></pre></td></tr></table></figure>
<h2 id="原始的指针操作"><strong>原始的指针操作</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sharpen</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;image, cv::Mat &amp;result)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// allocate if necessary</span></span><br><span class="line">	result.create(image.size(), image.type());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j= <span class="number">1</span>; j&lt;image.rows-<span class="number">1</span>; j++) </span><br><span class="line">	&#123; 	<span class="comment">// for all rows</span></span><br><span class="line">		<span class="comment">// (except first and last)</span></span><br><span class="line">		<span class="keyword">const</span> uchar *previous = image.ptr&lt;<span class="keyword">const</span> uchar&gt;(j-<span class="number">1</span>); 	<span class="comment">// previous row</span></span><br><span class="line">		<span class="keyword">const</span> uchar *current = image.ptr&lt;<span class="keyword">const</span> uchar&gt;(j); 		<span class="comment">// current row</span></span><br><span class="line">		<span class="keyword">const</span> uchar *next = image.ptr&lt;<span class="keyword">const</span> uchar&gt;(j+<span class="number">1</span>); 		<span class="comment">// next row</span></span><br><span class="line">		uchar* output= result.ptr&lt;uchar&gt;(j); 					<span class="comment">// output row</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;image.cols-<span class="number">1</span>; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			*output++= cv::saturate_cast&lt;uchar&gt;(<span class="number">5</span>*current[i] - current[i-<span class="number">1</span>] - current[i+<span class="number">1</span>] - previous[i] - next[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Set the unprocess pixels to 0</span></span><br><span class="line">	result.row(<span class="number">0</span>).setTo(cv::Scalar(<span class="number">0</span>));</span><br><span class="line">	result.row(result.rows-<span class="number">1</span>).setTo(cv::Scalar(<span class="number">0</span>));</span><br><span class="line">	result.col(<span class="number">0</span>).setTo(cv::Scalar(<span class="number">0</span>));</span><br><span class="line">	result.col(result.cols-<span class="number">1</span>).setTo(cv::Scalar(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里值得注意的两点:</p>
<ul>
<li><strong><code>cv::saturate_cast&lt;uchar&gt;</code> method</strong></li>
</ul>
<p>　　他的作用是：用来对计算结果进行截断(1) 小于0的像素值截断为0；(2)大于255的截断为255；(3)输入参数是浮点数的话，会对其取整至最接近输入值的整数。</p>
<ul>
<li><strong>边缘像素的处理</strong></li>
</ul>
<p>　　由于边缘像素的邻域不完整，无法按照上述进行操作运算，所以书上就直接让其变为0。使用OpenCV提供的函数进行如下操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.row(<span class="number">0</span>).setTo(cv::Scalar(<span class="number">0</span>));<span class="comment">//如果是一个三通道的图像，则需要使用cv::Scalar(0,0,0)来指定像素三个通道的目标值</span></span><br></pre></td></tr></table></figure>
<p><code>row</code> and <code>col</code> method ：They return a special <code>cv::Mat</code> instance composed of a single line (or a single column) as specified in a parameter. See <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html?highlight=setto#mat-row" target="_blank" rel="external">row</a>  and <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html?highlight=setto#mat-col" target="_blank" rel="external">col</a><br><code>cv::Mat::setTo</code> method: Sets all or some of the array elements to the specified value.    See <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html?highlight=setto#mat-setto" target="_blank" rel="external">setTo</a></p>
<h2 id="使用filter2D_method"><strong>使用<code>filter2D</code> method</strong></h2><p>　　尽量使用下面这种方法，相比上面那种方法，filter2D更高效简洁(书上说的)：<br>核矩阵：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> -<span class="number">1</span> <span class="number">0</span></span><br><span class="line">-<span class="number">1</span> <span class="number">5</span> -<span class="number">1</span></span><br><span class="line"><span class="number">0</span> -<span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sharpen2D</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;image, cv::Mat &amp;result)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	cv::<span class="function">Mat <span class="title">kernel</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, CV_32F, cv::Scalar(<span class="number">0</span>)</span>)</span>;<span class="comment">// Construct kernel (all entries initialized to 0)</span></span><br><span class="line">	<span class="comment">// assigns kernel values</span></span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">1</span>) = -<span class="number">1.0</span>;</span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>) = -<span class="number">1.0</span>;</span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">1</span>) = -<span class="number">1.0</span>;</span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">2</span>) = -<span class="number">1.0</span>;</span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">5.0</span>;</span><br><span class="line">	</span><br><span class="line">	cv::filter2D(image, result, image.depth(), kernel);	<span class="comment">//filter the image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Performing_simple_image_arithmetic"><strong>Performing simple image arithmetic</strong></h1><p>　　Images can be combined in different ways. Since they are regular matrices, they can be added, subtracted, multiplied, or divided. OpenCV offers various image arithmetic operators and their use is discussed in this recipe.</p>
<h2 id="简单的运算"><strong>简单的运算</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c[i]= a[i]+b[i];</span></span><br><span class="line">cv::add(imageA,imageB,resultC);</span><br><span class="line"><span class="comment">// c[i]= a[i]+k;</span></span><br><span class="line">cv::add(imageA,cv::Scalar(k),resultC);</span><br><span class="line"><span class="comment">// c[i]= k1*a[1]+k2*b[i]+k3;</span></span><br><span class="line">cv::addWeighted(imageA,k1,imageB,k2,k3,resultC);</span><br><span class="line"><span class="comment">// c[i]= k*a[1]+b[i];</span></span><br><span class="line">cv::scaleAdd(imageA,k,imageB,resultC);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (mask[i]) c[i]= a[i]+b[i];</span></span><br><span class="line">cv::add(imageA,imageB,resultC,mask);</span><br></pre></td></tr></table></figure>
<p>　　如果指定了掩模(mask)，运算只会在mask对应像素不为NULL的像素上进行((the mask must be 1-channel)；OpenCV还定义了许多运算，接下来只列举书上出现的，具体怎么用干啥的，参见OpenCV官方文档。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv::subtract, cv::absdiff, cv::multiply, cv::divide</span><br><span class="line">cv::bitwise_and, cv::bitwise_or, cv::bitwise_xor, cv::bitwise_not</span><br><span class="line">cv::min, cv::max</span><br><span class="line">cv::saturate_cast</span><br><span class="line">cv::<span class="built_in">sqrt</span>, cv::<span class="built_in">pow</span>,</span><br><span class="line">cv::<span class="built_in">abs</span>, cv::cuberoot, cv::<span class="built_in">exp</span>, cv::<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h2 id="Overloaded_image_operators"><strong>Overloaded image operators</strong></h2><p>1.<code>cv::addWeighted</code> can be written as:    <code>result= 0.7*image1+0.9*image2;</code><br>2.大多数操作符都被重载了，如<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>.  the comparison operators &lt;, &lt;=, ==,!=, &gt;, &gt;=;these laterreturning a 8-bit binary image.<br>3.矩阵乘法<code>m1*m2</code>(m1,m2是cv::Mat的实例)，矩阵求逆(matrix inversion)<code>m1.inv()</code> , 矩阵转置(transpose)<code>m1.t()</code> , 矩阵的行列式(determinant)<code>m1.determinant()</code> , 向量模(vector norm)<code>v1.norm()</code> , 向量叉乘(cross-product)<code>v1.cross(v2)</code>, 向量点积(dot product)<code>v1.dot(v2)</code> .<br>4.前面的循环遍历实现图像颜色缩减可以用一行代码来写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image = (image&amp;cv::Scalar(mask,mask,mask)) + cv::Scalar(div/<span class="number">2</span>,div/<span class="number">2</span>,div/<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>　　但是这个耗时比较长，89ms，调用位运算与标量和预算(而且不是在同一个for循环里完成这个操作)但是因为其简洁，大多数情况考虑用他们。(不是特别注重时间性能的话)</p>
<h2 id="Splitting_the_image_channels"><strong>Splitting the image channels</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create vector of 3 images</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; planes;</span><br><span class="line"><span class="comment">// split 1 3-channel image into 3 1-channel images</span></span><br><span class="line">cv::split(image1,planes);</span><br><span class="line"><span class="comment">// add to blue channel</span></span><br><span class="line">planes[<span class="number">0</span>]+= image2;		<span class="comment">//planes[0],通道1；planes[1],通道2；planes[2],通道3；</span></span><br><span class="line"><span class="comment">// merge the 3 1-channel images into 1 3-channel image</span></span><br><span class="line">cv::merge(planes,result);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Defining_regions_of_interest"><strong>Defining regions of interest</strong></h1><p>　　如果想把一张小图片往大图片上贴，由于大小尺寸不同，无法直接用<code>cv::add</code>,这时候就需要定义感兴趣区域(ROI, regions of interest).</p>
<h2 id="实现方法-1"><strong>实现方法</strong></h2><p>　　定义感兴趣区域，插入图像：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define image ROI</span></span><br><span class="line">cv::Mat imageROI;</span><br><span class="line">imageROI = image(cv::Rect(<span class="number">385</span>, <span class="number">270</span>, logo.cols, logo.rows));</span><br><span class="line"><span class="comment">// add logo to image</span></span><br><span class="line">cv::addWeighted(imageROI, <span class="number">1.0</span>, logo, <span class="number">0.3</span>, <span class="number">0.</span>, imageROI);</span><br></pre></td></tr></table></figure></p>
<p>　　我们知道<code>cv::Mat</code>赋值操作只是浅拷贝，他们共享一块内存，也就是说imageROI指向的就是原图片，改变imageROI，意味着改变原图像，从而实现插入。　但是在书上的图中我们看到，效果不明显，因为直接相加，可能像素值超过255，然后使其为255，这样就造成效果不明显，所以书上又提供了掩模来操作，直接替换原图像该位置的像素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define ROI</span></span><br><span class="line">imageROI = image(cv::Rect(<span class="number">385</span>, <span class="number">270</span>, logo.cols, logo.rows));</span><br><span class="line"><span class="comment">// load the mask (must be gray-level)</span></span><br><span class="line">cv::Mat mask = cv::imread(<span class="string">"logo.bmp"</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// copy to ROI with mask</span></span><br><span class="line">logo.copyTo(imageROI, mask);</span><br></pre></td></tr></table></figure>
<p>　　掩模的作用就是只处理原图像中对应掩模元素不为NULL的位置的元素。比如掩模(1, 1)处为NULL，那么原图像该位置就不处理，如果该位置不为NULL，那么原图像这个位置像素就处理。</p>
<h2 id="定义ROI的方法"><strong>定义ROI的方法</strong></h2><p>(1)上面已经给出一种方法了，使用<code>cv::Rect</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat imageROI;</span><br><span class="line">imageROI = image(cv::Rect(<span class="number">385</span>, <span class="number">270</span>, logo.cols, logo.rows));</span><br></pre></td></tr></table></figure></p>
<p>(2)这里介绍第二种方法,使用<code>cv::Range</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat imageROI = image(cv::Range(<span class="number">270</span>,<span class="number">270</span>+logo.rows), cv::Range(<span class="number">385</span>,<span class="number">385</span>+logo.cols));</span><br></pre></td></tr></table></figure></p>
<p><code>cv::Range</code>是指从起始索引到终止索引(不包含终止索引)的一段连续序列。<br>(3)第二种方法的扩展<br>创建原始图像特定行/列的ROI<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat imageROI = image.rowRange(start, end);	<span class="comment">//行</span></span><br><span class="line">cv::Mat imageROI = image.colRange(start, end);	<span class="comment">//列</span></span><br></pre></td></tr></table></figure></p>
<hr>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/10/28/151028-OpenCV-Processing-images-with-classes/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          OpenCV 学习笔记(3) Processing images with classes
        
      </div>
    </a>
  
  
    <a href="/2015/10/26/151026-OpenCV-Manipulating-the-Pixels/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">OpenCV 学习笔记(2) Manipulating the Pixels (上)</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="151026-OpenCV-Manipulating-the-pixels-2" data-title="OpenCV 学习笔记(2) Manipulating the Pixels (下)" data-url="site:ocxsBlog.github.io/2015/10/26/151026-OpenCV-Manipulating-the-pixels-2/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 ocxs
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div id="totop" style="position:fixed;bottom:100px;right:50px;cursor: pointer;">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>
  </div>
</body>
</html>