<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>OpenCV 学习笔记(2) Manipulating the Pixels (下) | Ocxs&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本节导读：


Writing effcient image scanning loops
Scanning an image with neighbor access
Performing simple image arithmetic 
Defining regions of interest">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV 学习笔记(2) Manipulating the Pixels (下)">
<meta property="og:url" content="site:ocxs.coding.io/2015/10/26/151026-OpenCV-Manipulating-the-pixels-2/index.html">
<meta property="og:site_name" content="Ocxs's blog">
<meta property="og:description" content="本节导读：


Writing effcient image scanning loops
Scanning an image with neighbor access
Performing simple image arithmetic 
Defining regions of interest">
<meta property="og:updated_time" content="2015-10-28T06:00:06.506Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenCV 学习笔记(2) Manipulating the Pixels (下)">
<meta name="twitter:description" content="本节导读：


Writing effcient image scanning loops
Scanning an image with neighbor access
Performing simple image arithmetic 
Defining regions of interest">
  
    <link rel="alternative" href="/atom.xml" title="Ocxs&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ocxs</a></h1>
		</hgroup>

		
		<p class="header-subtitle">To be better</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Computer-Vision/" style="font-size: 10px;">Computer Vision</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/PAT/" style="font-size: 20px;">PAT</a> <a href="/tags/PAT-data-structure/" style="font-size: 20px;">PAT data structure</a> <a href="/tags/data-structure/" style="font-size: 15px;">data structure</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">To be better!</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ocxs</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/avatar.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">ocxs</h1>
			</hgroup>
			
			<p class="header-subtitle">To be better</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-151026-OpenCV-Manipulating-the-pixels-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/26/151026-OpenCV-Manipulating-the-pixels-2/" class="article-date">
  	<time datetime="2015-10-26T13:17:43.000Z" itemprop="datePublished">2015-10-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      OpenCV 学习笔记(2) Manipulating the Pixels (下)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Vision/">Computer Vision</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenCV/">OpenCV</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本节导读：</p>
<blockquote>
<ul>
<li>Writing effcient image scanning loops</li>
<li>Scanning an image with neighbor access</li>
<li>Performing simple image arithmetic </li>
<li>Defining regions of interest<a id="more"></a>
</li>
</ul>
</blockquote>
<h1 id="一-Writing_effcient_image_scanning_loops(编写高效的图像遍历循环)"><strong>一.Writing effcient image scanning loops(编写高效的图像遍历循环)</strong></h1><p>除非必要，否则不能以降低代码清晰度的代价去提升性能，简单的代码易维护和调试。</p>
<h2 id="1-实现方法">1.实现方法</h2><p>实现方法在上一节里都写得差不多了，这一块主要是做对比分析，如图所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Method</th>
<th>Average time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">data[i]= data[i]/div*div + div/2;</td>
<td>37ms</td>
</tr>
<tr>
<td style="text-align:center">*data++= *data/div*div + div/2;</td>
<td>37ms</td>
</tr>
<tr>
<td style="text-align:center">*data++= v - v%div + div/2;</td>
<td>52ms</td>
</tr>
<tr>
<td style="text-align:center">*data++= *data&amp;mask + div/2;</td>
<td>35ms</td>
</tr>
<tr>
<td style="text-align:center">colorReduce(input, output);</td>
<td>44ms</td>
</tr>
<tr>
<td style="text-align:center">i&lt;image.cols*image.channels();</td>
<td>65ms</td>
</tr>
<tr>
<td style="text-align:center">MatIterator</td>
<td>67ms</td>
</tr>
<tr>
<td style="text-align:center">.at(j,i)</td>
<td>80ms</td>
</tr>
<tr>
<td style="text-align:center">3-channel loop</td>
<td>29ms</td>
</tr>
</tbody>
</table>
<p>这里书上介绍了两个函数，<code>cv::getTickCount()</code>和<code>cv::getTickFrequency()</code>;用法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> duration;</span><br><span class="line">duration = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(cv::getTickCount());</span><br><span class="line">colorReduce(image); <span class="comment">// the function to be tested</span></span><br><span class="line">duration = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(cv::getTickCount())-duration;</span><br><span class="line">duration /= cv::getTickFrequency(); <span class="comment">// the elapsed time in ms</span></span><br></pre></td></tr></table></figure></p>
<p>不得不说代码写的还真规范，要是我这样的渣写，肯定就不会想到用<code>static_cast&lt;double&gt;</code>来强制转换，直接<code>(double)</code>;<br>从上面的表格中可以看出，用指针遍历快，迭代器遍历慢。<code>at</code>最慢，不过<code>at</code>的设计是用来随机存取像素值的，不适用遍历整幅图像。<br>迭代器的设计目标就是简化图像遍历的过程从而降低出错的机会，所以如果遍历整幅图像还是用指针，快，作为程序员，应该有避免错误的能力。</p>
<p>下面介绍一下书上提到的一些优化细节，</p>
<h3 id="(1)能提前计算的都提前计算出来">(1)能提前计算的都提前计算出来</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nc= image.cols * image.channels();</span><br><span class="line">…</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nc; i++) &#123;</span><br></pre></td></tr></table></figure>
<p>来替换<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;image.cols * image.channels(); i++) &#123;</span><br></pre></td></tr></table></figure></p>
<p>这样就不用每次都要来计算<code>image.channels()</code>，重复计算有耗时，应丢弃，提前计算好用局部变量存储起来。</p>
<h3 id="(2)能在一个循环里解决的就不要在折腾了">(2)能在一个循环里解决的就不要在折腾了</h3><p>比如在处理三通道图像时，之前的代码中，内层循环有是这么设计的，使循环次数为<code>image.cols * image.channels()</code>，书上就说了，我们可以使循环次数变成<code>image.cols</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">colorReduce</span><span class="params">(cv::Mat &amp;image, <span class="keyword">int</span> div=<span class="number">64</span>)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nl= image.rows; <span class="comment">// number of lines</span></span><br><span class="line">	<span class="keyword">int</span> nc= image.cols ; <span class="comment">// number of columns</span></span><br><span class="line">	<span class="comment">// is it a continous image?</span></span><br><span class="line">	<span class="keyword">if</span> (image.isContinuous()) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// then no padded pixels</span></span><br><span class="line">		nc= nc*nl;</span><br><span class="line">		nl= <span class="number">1</span>; <span class="comment">// it is now a 1D array</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nl; j++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// pointer to first column of line j</span></span><br><span class="line">		uchar* data= image.ptr&lt;uchar&gt;(j);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nc; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			*data++= div/<span class="number">2</span>;	<span class="comment">//data[i][0]</span></span><br><span class="line">			*data++= div/<span class="number">2</span>;	<span class="comment">//data[i][1]</span></span><br><span class="line">			*data++= div/<span class="number">2</span>;	<span class="comment">//data[i][2]</span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，按照书上的意思是<strong>最快的图像遍历</strong>方法了！(如果我没理解错的话，有错欢迎指正！)</p>
<h2 id="2-扩展">2.扩展</h2><p>多线程处理是另外一个提升算法效率的方式，OpenMP 与 Intel Threading Building Blocks(TBB)是两个比较流行的并行编程API。<br>VS2013里有可以直接用OpenMP，具体用法搜索一下，我用过，基础的操作还是蛮简单的，看一下就会用了，奈何自己笔记本就两核，只提升了2倍。</p>
<h1 id="二-Scanning_an_image_with_neighbor_access(遍历图像和邻域操作)"><strong>二.Scanning an image with neighbor access(遍历图像和邻域操作)</strong></h1><p>与其说这一节教你怎么进行邻域操作，倒不如说教你怎么进行图像锐化，一共两种方法，第一种原始的指针操作，第二种自定义核算子，利用OpenCV函数<code>filter2D</code>来操作，更加快捷，二者结果一样，甚至核的尺寸如果比较大，后者效率更高。<br>锐化算子的计算方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sharpened_pixel= <span class="number">5</span> * current - left - right - up - down;</span><br><span class="line"><span class="comment">//current代表当前像素值，left代表当前像素位置左边的像素值，依次类推</span></span><br></pre></td></tr></table></figure></p>
<h2 id="1-原始的指针操作">1.原始的指针操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sharpen</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;image, cv::Mat &amp;result)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// allocate if necessary</span></span><br><span class="line">	result.create(image.size(), image.type());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j= <span class="number">1</span>; j&lt;image.rows-<span class="number">1</span>; j++) </span><br><span class="line">	&#123; 	<span class="comment">// for all rows</span></span><br><span class="line">		<span class="comment">// (except first and last)</span></span><br><span class="line">		<span class="keyword">const</span> uchar *previous = image.ptr&lt;<span class="keyword">const</span> uchar&gt;(j-<span class="number">1</span>); 	<span class="comment">// previous row</span></span><br><span class="line">		<span class="keyword">const</span> uchar *current = image.ptr&lt;<span class="keyword">const</span> uchar&gt;(j); 		<span class="comment">// current row</span></span><br><span class="line">		<span class="keyword">const</span> uchar *next = image.ptr&lt;<span class="keyword">const</span> uchar&gt;(j+<span class="number">1</span>); 		<span class="comment">// next row</span></span><br><span class="line">		uchar* output= result.ptr&lt;uchar&gt;(j); 					<span class="comment">// output row</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;image.cols-<span class="number">1</span>; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			*output++= cv::saturate_cast&lt;uchar&gt;(<span class="number">5</span>*current[i] - current[i-<span class="number">1</span>] - current[i+<span class="number">1</span>] - previous[i] - next[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Set the unprocess pixels to 0</span></span><br><span class="line">	result.row(<span class="number">0</span>).setTo(cv::Scalar(<span class="number">0</span>));</span><br><span class="line">	result.row(result.rows-<span class="number">1</span>).setTo(cv::Scalar(<span class="number">0</span>));</span><br><span class="line">	result.col(<span class="number">0</span>).setTo(cv::Scalar(<span class="number">0</span>));</span><br><span class="line">	result.col(result.cols-<span class="number">1</span>).setTo(cv::Scalar(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里值得注意的两点</p>
<h3 id="(1)cv::saturate_cast&lt;uchar&gt;_method">(1)<code>cv::saturate_cast&lt;uchar&gt;</code> method</h3><p>他的作用是：用来对计算结果进行截断(1) 小于0的像素值截断为0；(2)大于255的截断为255；(3)输入参数是浮点数的话，会对其取整至最接近输入值的整数。</p>
<h3 id="(2)边缘像素的处理">(2)边缘像素的处理</h3><p>由于边缘像素的邻域不完整，无法按照上述进行操作运算，所以书上就直接让其变为0。使用OpenCV提供的函数进行如下操作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.row(<span class="number">0</span>).setTo(cv::Scalar(<span class="number">0</span>));<span class="comment">//如果是一个三通道的图像，则需要使用cv::Scalar(0,0,0)来指定像素三个通道的目标值</span></span><br></pre></td></tr></table></figure></p>
<p><code>row</code> and <code>col</code> method ：They return a special <code>cv::Mat</code> instance composed of a single line (or a single column) as specified in a parameter. See <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html?highlight=setto#mat-row" target="_blank" rel="external">row</a>  and <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html?highlight=setto#mat-col" target="_blank" rel="external">col</a><br><code>cv::Mat::setTo</code> method: Sets all or some of the array elements to the specified value.    See <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html?highlight=setto#mat-setto" target="_blank" rel="external">setTo</a></p>
<h2 id="2-使用filter2D_method">2.使用<code>filter2D</code> method</h2><p>尽量使用下面这种方法，相比上面那种方法，filter2D更高效简洁(书上说的)<br>核矩阵：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> -<span class="number">1</span> <span class="number">0</span></span><br><span class="line">-<span class="number">1</span> <span class="number">5</span> -<span class="number">1</span></span><br><span class="line"><span class="number">0</span> -<span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sharpen2D</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;image, cv::Mat &amp;result)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	cv::<span class="function">Mat <span class="title">kernel</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, CV_32F, cv::Scalar(<span class="number">0</span>)</span>)</span>;<span class="comment">// Construct kernel (all entries initialized to 0)</span></span><br><span class="line">	<span class="comment">// assigns kernel values</span></span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">1</span>) = -<span class="number">1.0</span>;</span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>) = -<span class="number">1.0</span>;</span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">1</span>) = -<span class="number">1.0</span>;</span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">2</span>) = -<span class="number">1.0</span>;</span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">5.0</span>;</span><br><span class="line">	</span><br><span class="line">	cv::filter2D(image, result, image.depth(), kernel);	<span class="comment">//filter the image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三-Performing_simple_image_arithmetic(进行简单的图像算术)"><strong>三.Performing simple image arithmetic(进行简单的图像算术)</strong></h1><p>Images can be combined in different ways. Since they are regular matrices, they can be added, subtracted, multiplied, or divided. OpenCV offers various image arithmetic operators and their use is discussed in this recipe.</p>
<h2 id="1-运算">1.运算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c[i]= a[i]+b[i];</span></span><br><span class="line">cv::add(imageA,imageB,resultC);</span><br><span class="line"><span class="comment">// c[i]= a[i]+k;</span></span><br><span class="line">cv::add(imageA,cv::Scalar(k),resultC);</span><br><span class="line"><span class="comment">// c[i]= k1*a[1]+k2*b[i]+k3;</span></span><br><span class="line">cv::addWeighted(imageA,k1,imageB,k2,k3,resultC);</span><br><span class="line"><span class="comment">// c[i]= k*a[1]+b[i];</span></span><br><span class="line">cv::scaleAdd(imageA,k,imageB,resultC);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (mask[i]) c[i]= a[i]+b[i];</span></span><br><span class="line">cv::add(imageA,imageB,resultC,mask);</span><br></pre></td></tr></table></figure>
<p>如果指定了掩模(mask)，运算只会在mask对应像素不为NULL的像素上进行((the mask must be 1-channel)；<br>OpenCV还定义了许多运算，接下来只列举书上出现的，具体怎么用干啥的，参见OpenCV官方文档。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv::subtract, cv::absdiff, cv::multiply, cv::divide</span><br><span class="line">cv::bitwise_and, cv::bitwise_or, cv::bitwise_xor, cv::bitwise_not</span><br><span class="line">cv::min, cv::max</span><br><span class="line">cv::saturate_cast</span><br><span class="line">cv::<span class="built_in">sqrt</span>, cv::<span class="built_in">pow</span>,</span><br><span class="line">cv::<span class="built_in">abs</span>, cv::cuberoot, cv::<span class="built_in">exp</span>, cv::<span class="built_in">log</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-扩展阅读">2.扩展阅读</h2><h3 id="(1)Overloaded_image_operators(重载图像操作符)">(1)Overloaded image operators(重载图像操作符)</h3><p>1.<code>cv::addWeighted</code> can be written as:    <code>result= 0.7*image1+0.9*image2;</code><br>2.大多数操作符都被重载了，如<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>.  the comparison operators &lt;, &lt;=, ==,!=, &gt;, &gt;=;these laterreturning a 8-bit binary image.<br>3.矩阵乘法<code>m1*m2</code>(m1,m2是cv::Mat的实例)，矩阵求逆(matrix inversion)<code>m1.inv()</code> , 矩阵转置(transpose)<code>m1.t()</code> , 矩阵的行列式(determinant)<code>m1.determinant()</code> , 向量模(vector norm)<code>v1.norm()</code> , 向量叉乘(cross-product)<code>v1.cross(v2)</code>, 向量点积(dot product)<code>v1.dot(v2)</code> .<br>4.前面的循环遍历实现图像颜色缩减可以用一行代码来写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image = (image&amp;cv::Scalar(mask,mask,mask)) + cv::Scalar(div/<span class="number">2</span>,div/<span class="number">2</span>,div/<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>但是这个耗时比较长，89ms，调用位运算与标量和预算(而且不是在同一个for循环里完成这个操作)但是因为其简洁，大多数情况考虑用他们。(不是特别注重时间性能的话)</p>
<h3 id="(2)Splitting_the_image_channels(分离图像通道)">(2)Splitting the image channels(分离图像通道)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create vector of 3 images</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; planes;</span><br><span class="line"><span class="comment">// split 1 3-channel image into 3 1-channel images</span></span><br><span class="line">cv::split(image1,planes);</span><br><span class="line"><span class="comment">// add to blue channel</span></span><br><span class="line">planes[<span class="number">0</span>]+= image2;		<span class="comment">//planes[0],通道1；planes[1],通道2；planes[2],通道3；</span></span><br><span class="line"><span class="comment">// merge the 3 1-channel images into 1 3-channel image</span></span><br><span class="line">cv::merge(planes,result);</span><br></pre></td></tr></table></figure>
<h1 id="四-Defining_regions_of_interest(定义感兴趣区域)"><strong>四.Defining regions of interest(定义感兴趣区域)</strong></h1>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/10/26/151026-OpenCV-Manipulating-the-Pixels/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">OpenCV 学习笔记(2) Manipulating the Pixels (上)</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="151026-OpenCV-Manipulating-the-pixels-2" data-title="OpenCV 学习笔记(2) Manipulating the Pixels (下)" data-url="site:ocxs.coding.io/2015/10/26/151026-OpenCV-Manipulating-the-pixels-2/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 ocxs
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>