<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Computer Vision,OpenCV," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="本节导读：


Writing effcient image scanning loops(编写高效的图像遍历循环)
Scanning an image with neighbor access(遍历图像和邻域操作)
Performing simple image arithmetic 
Defining regions of interest">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV 学习笔记(2) Manipulating the Pixels (下)">
<meta property="og:url" content="site:ocxsBlog.github.io/2015/10/26/151026-OpenCV-Manipulating-the-pixels-2/index.html">
<meta property="og:site_name" content="Ocxs's blog">
<meta property="og:description" content="本节导读：


Writing effcient image scanning loops(编写高效的图像遍历循环)
Scanning an image with neighbor access(遍历图像和邻域操作)
Performing simple image arithmetic 
Defining regions of interest">
<meta property="og:updated_time" content="1970-01-01T00:00:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenCV 学习笔记(2) Manipulating the Pixels (下)">
<meta name="twitter:description" content="本节导读：


Writing effcient image scanning loops(编写高效的图像遍历循环)
Scanning an image with neighbor access(遍历图像和邻域操作)
Performing simple image arithmetic 
Defining regions of interest">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> OpenCV 学习笔记(2) Manipulating the Pixels (下) | Ocxs's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Ocxs's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">To be better</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                OpenCV 学习笔记(2) Manipulating the Pixels (下)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2015-10-26T21:17:43+08:00" content="2015-10-26">
              2015-10-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/10/26/151026-OpenCV-Manipulating-the-pixels-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/26/151026-OpenCV-Manipulating-the-pixels-2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本节导读：</p>
<blockquote>
<ul>
<li>Writing effcient image scanning loops(编写高效的图像遍历循环)</li>
<li>Scanning an image with neighbor access(遍历图像和邻域操作)</li>
<li>Performing simple image arithmetic </li>
<li>Defining regions of interest<a id="more"></a>
</li>
</ul>
</blockquote>
<h1 id="Writing_effcient_image_scanning_loops"><strong>Writing effcient image scanning loops</strong></h1><p>　　除非必要，否则不能以降低代码清晰度的代价去提升性能，简单的代码易维护和调试。</p>
<h2 id="实现方法"><strong>实现方法</strong></h2><p>　　实现方法在上一节里都写得差不多了，这一块主要是做对比分析，如图所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Average time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">data[i]= data[i]/div*div + div/2;</td>
<td style="text-align:center">37ms</td>
</tr>
<tr>
<td style="text-align:center">*data++= *data/div*div + div/2;</td>
<td style="text-align:center">37ms</td>
</tr>
<tr>
<td style="text-align:center">*data++= v - v%div + div/2;</td>
<td style="text-align:center">52ms</td>
</tr>
<tr>
<td style="text-align:center">*data++= *data&amp;mask + div/2;</td>
<td style="text-align:center">35ms</td>
</tr>
<tr>
<td style="text-align:center">colorReduce(input, output);</td>
<td style="text-align:center">44ms</td>
</tr>
<tr>
<td style="text-align:center">i&lt;image.cols*image.channels();</td>
<td style="text-align:center">65ms</td>
</tr>
<tr>
<td style="text-align:center">MatIterator</td>
<td style="text-align:center">67ms</td>
</tr>
<tr>
<td style="text-align:center">.at(j,i)</td>
<td style="text-align:center">80ms</td>
</tr>
<tr>
<td style="text-align:center">3-channel loop</td>
<td style="text-align:center">29ms</td>
</tr>
</tbody>
</table>
<p>　　这里书上介绍了两个函数，<code>cv::getTickCount()</code>和<code>cv::getTickFrequency()</code>;用法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> duration;</span><br><span class="line">duration = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(cv::getTickCount());</span><br><span class="line">colorReduce(image); <span class="comment">// the function to be tested</span></span><br><span class="line">duration = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(cv::getTickCount())-duration;</span><br><span class="line">duration /= cv::getTickFrequency(); <span class="comment">// the elapsed time in ms</span></span><br></pre></td></tr></table></figure></p>
<p>　　不得不说代码写的还真规范，要是我这样的渣写，肯定就不会想到用<code>static_cast&lt;double&gt;</code>来强制转换，直接<code>(double)</code>;从上面的表格中可以看出，用指针遍历快，迭代器遍历慢。<code>at</code>最慢，不过<code>at</code>的设计是用来随机存取像素值的，不适用遍历整幅图像。<br>　　迭代器的设计目标就是简化图像遍历的过程从而降低出错的机会，所以如果遍历整幅图像还是用指针，快，作为程序员，应该有避免错误的能力。</p>
<p>　　下面介绍一下书上提到的一些<strong>优化细节</strong>:</p>
<ul>
<li><strong>能提前计算的都提前计算出来</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nc= image.cols * image.channels();</span><br><span class="line">…</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nc; i++) &#123;</span><br></pre></td></tr></table></figure>
<p>来替换<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;image.cols * image.channels(); i++) &#123;</span><br></pre></td></tr></table></figure></p>
<p>　　这样就不用每次都要来计算<code>image.channels()</code>，重复计算有耗时，应丢弃，提前计算好用局部变量存储起来。</p>
<ul>
<li><strong>能在一个循环里解决的就不要在折腾</strong></li>
</ul>
<p>　　比如在处理三通道图像时，之前的代码中，内层循环有是这么设计的，使循环次数为<code>image.cols * image.channels()</code>，书上就说了，我们可以使循环次数变成<code>image.cols</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">colorReduce</span><span class="params">(cv::Mat &amp;image, <span class="keyword">int</span> div=<span class="number">64</span>)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nl= image.rows; <span class="comment">// number of lines</span></span><br><span class="line">	<span class="keyword">int</span> nc= image.cols ; <span class="comment">// number of columns</span></span><br><span class="line">	<span class="comment">// is it a continous image?</span></span><br><span class="line">	<span class="keyword">if</span> (image.isContinuous()) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// then no padded pixels</span></span><br><span class="line">		nc= nc*nl;</span><br><span class="line">		nl= <span class="number">1</span>; <span class="comment">// it is now a 1D array</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nl; j++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// pointer to first column of line j</span></span><br><span class="line">		uchar* data= image.ptr&lt;uchar&gt;(j);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nc; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			*data++= div/<span class="number">2</span>;	<span class="comment">//data[i][0]</span></span><br><span class="line">			*data++= div/<span class="number">2</span>;	<span class="comment">//data[i][1]</span></span><br><span class="line">			*data++= div/<span class="number">2</span>;	<span class="comment">//data[i][2]</span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　上面这段代码，按照书上的意思是<strong>最快的图像遍历</strong>方法了！(如果我没理解错的话，有错欢迎指正！)</p>
<h2 id="OpenMP_and_TBB"><strong>OpenMP and TBB</strong></h2><p>　　多线程处理是另外一个提升算法效率的方式，OpenMP 与 Intel Threading Building Blocks(TBB)是两个比较流行的并行编程API。VS2013里有可以直接用OpenMP，具体用法搜索一下，我用过，基础的操作还是蛮简单的，看一下就会用了，奈何自己笔记本就两核，只提升了2倍。</p>
<hr>
<h1 id="Scanning_an_image_with_neighbor_access"><strong>Scanning an image with neighbor access</strong></h1><p>　　与其说这一节教你怎么进行邻域操作，倒不如说教你怎么进行图像锐化，一共两种方法，第一种原始的指针操作，第二种自定义核算子，利用OpenCV函数<code>filter2D</code>来操作，更加快捷，二者结果一样，甚至核的尺寸如果比较大，后者效率更高。<br>锐化算子的计算方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sharpened_pixel= <span class="number">5</span> * current - left - right - up - down;</span><br><span class="line"><span class="comment">//current代表当前像素值，left代表当前像素位置左边的像素值，依次类推</span></span><br></pre></td></tr></table></figure>
<h2 id="原始的指针操作"><strong>原始的指针操作</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sharpen</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;image, cv::Mat &amp;result)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// allocate if necessary</span></span><br><span class="line">	result.create(image.size(), image.type());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j= <span class="number">1</span>; j&lt;image.rows-<span class="number">1</span>; j++) </span><br><span class="line">	&#123; 	<span class="comment">// for all rows</span></span><br><span class="line">		<span class="comment">// (except first and last)</span></span><br><span class="line">		<span class="keyword">const</span> uchar *previous = image.ptr&lt;<span class="keyword">const</span> uchar&gt;(j-<span class="number">1</span>); 	<span class="comment">// previous row</span></span><br><span class="line">		<span class="keyword">const</span> uchar *current = image.ptr&lt;<span class="keyword">const</span> uchar&gt;(j); 		<span class="comment">// current row</span></span><br><span class="line">		<span class="keyword">const</span> uchar *next = image.ptr&lt;<span class="keyword">const</span> uchar&gt;(j+<span class="number">1</span>); 		<span class="comment">// next row</span></span><br><span class="line">		uchar* output= result.ptr&lt;uchar&gt;(j); 					<span class="comment">// output row</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;image.cols-<span class="number">1</span>; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			*output++= cv::saturate_cast&lt;uchar&gt;(<span class="number">5</span>*current[i] - current[i-<span class="number">1</span>] - current[i+<span class="number">1</span>] - previous[i] - next[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Set the unprocess pixels to 0</span></span><br><span class="line">	result.row(<span class="number">0</span>).setTo(cv::Scalar(<span class="number">0</span>));</span><br><span class="line">	result.row(result.rows-<span class="number">1</span>).setTo(cv::Scalar(<span class="number">0</span>));</span><br><span class="line">	result.col(<span class="number">0</span>).setTo(cv::Scalar(<span class="number">0</span>));</span><br><span class="line">	result.col(result.cols-<span class="number">1</span>).setTo(cv::Scalar(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里值得注意的两点:</p>
<ul>
<li><strong><code>cv::saturate_cast&lt;uchar&gt;</code> method</strong></li>
</ul>
<p>　　他的作用是：用来对计算结果进行截断(1) 小于0的像素值截断为0；(2)大于255的截断为255；(3)输入参数是浮点数的话，会对其取整至最接近输入值的整数。</p>
<ul>
<li><strong>边缘像素的处理</strong></li>
</ul>
<p>　　由于边缘像素的邻域不完整，无法按照上述进行操作运算，所以书上就直接让其变为0。使用OpenCV提供的函数进行如下操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.row(<span class="number">0</span>).setTo(cv::Scalar(<span class="number">0</span>));<span class="comment">//如果是一个三通道的图像，则需要使用cv::Scalar(0,0,0)来指定像素三个通道的目标值</span></span><br></pre></td></tr></table></figure>
<p><code>row</code> and <code>col</code> method ：They return a special <code>cv::Mat</code> instance composed of a single line (or a single column) as specified in a parameter. See <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html?highlight=setto#mat-row" target="_blank" rel="external">row</a>  and <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html?highlight=setto#mat-col" target="_blank" rel="external">col</a><br><code>cv::Mat::setTo</code> method: Sets all or some of the array elements to the specified value.    See <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html?highlight=setto#mat-setto" target="_blank" rel="external">setTo</a></p>
<h2 id="使用filter2D_method"><strong>使用<code>filter2D</code> method</strong></h2><p>　　尽量使用下面这种方法，相比上面那种方法，filter2D更高效简洁(书上说的)：<br>核矩阵：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> -<span class="number">1</span> <span class="number">0</span></span><br><span class="line">-<span class="number">1</span> <span class="number">5</span> -<span class="number">1</span></span><br><span class="line"><span class="number">0</span> -<span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sharpen2D</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;image, cv::Mat &amp;result)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	cv::<span class="function">Mat <span class="title">kernel</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, CV_32F, cv::Scalar(<span class="number">0</span>)</span>)</span>;<span class="comment">// Construct kernel (all entries initialized to 0)</span></span><br><span class="line">	<span class="comment">// assigns kernel values</span></span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">1</span>) = -<span class="number">1.0</span>;</span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>) = -<span class="number">1.0</span>;</span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">1</span>) = -<span class="number">1.0</span>;</span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">2</span>) = -<span class="number">1.0</span>;</span><br><span class="line">	kernel.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">5.0</span>;</span><br><span class="line">	</span><br><span class="line">	cv::filter2D(image, result, image.depth(), kernel);	<span class="comment">//filter the image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Performing_simple_image_arithmetic"><strong>Performing simple image arithmetic</strong></h1><p>　　Images can be combined in different ways. Since they are regular matrices, they can be added, subtracted, multiplied, or divided. OpenCV offers various image arithmetic operators and their use is discussed in this recipe.</p>
<h2 id="简单的运算"><strong>简单的运算</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c[i]= a[i]+b[i];</span></span><br><span class="line">cv::add(imageA,imageB,resultC);</span><br><span class="line"><span class="comment">// c[i]= a[i]+k;</span></span><br><span class="line">cv::add(imageA,cv::Scalar(k),resultC);</span><br><span class="line"><span class="comment">// c[i]= k1*a[1]+k2*b[i]+k3;</span></span><br><span class="line">cv::addWeighted(imageA,k1,imageB,k2,k3,resultC);</span><br><span class="line"><span class="comment">// c[i]= k*a[1]+b[i];</span></span><br><span class="line">cv::scaleAdd(imageA,k,imageB,resultC);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (mask[i]) c[i]= a[i]+b[i];</span></span><br><span class="line">cv::add(imageA,imageB,resultC,mask);</span><br></pre></td></tr></table></figure>
<p>　　如果指定了掩模(mask)，运算只会在mask对应像素不为NULL的像素上进行((the mask must be 1-channel)；OpenCV还定义了许多运算，接下来只列举书上出现的，具体怎么用干啥的，参见OpenCV官方文档。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv::subtract, cv::absdiff, cv::multiply, cv::divide</span><br><span class="line">cv::bitwise_and, cv::bitwise_or, cv::bitwise_xor, cv::bitwise_not</span><br><span class="line">cv::min, cv::max</span><br><span class="line">cv::saturate_cast</span><br><span class="line">cv::<span class="built_in">sqrt</span>, cv::<span class="built_in">pow</span>,</span><br><span class="line">cv::<span class="built_in">abs</span>, cv::cuberoot, cv::<span class="built_in">exp</span>, cv::<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h2 id="Overloaded_image_operators"><strong>Overloaded image operators</strong></h2><p>1.<code>cv::addWeighted</code> can be written as:    <code>result= 0.7*image1+0.9*image2;</code><br>2.大多数操作符都被重载了，如<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>.  the comparison operators &lt;, &lt;=, ==,!=, &gt;, &gt;=;these laterreturning a 8-bit binary image.<br>3.矩阵乘法<code>m1*m2</code>(m1,m2是cv::Mat的实例)，矩阵求逆(matrix inversion)<code>m1.inv()</code> , 矩阵转置(transpose)<code>m1.t()</code> , 矩阵的行列式(determinant)<code>m1.determinant()</code> , 向量模(vector norm)<code>v1.norm()</code> , 向量叉乘(cross-product)<code>v1.cross(v2)</code>, 向量点积(dot product)<code>v1.dot(v2)</code> .<br>4.前面的循环遍历实现图像颜色缩减可以用一行代码来写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image = (image&amp;cv::Scalar(mask,mask,mask)) + cv::Scalar(div/<span class="number">2</span>,div/<span class="number">2</span>,div/<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>　　但是这个耗时比较长，89ms，调用位运算与标量和预算(而且不是在同一个for循环里完成这个操作)但是因为其简洁，大多数情况考虑用他们。(不是特别注重时间性能的话)</p>
<h2 id="Splitting_the_image_channels"><strong>Splitting the image channels</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create vector of 3 images</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; planes;</span><br><span class="line"><span class="comment">// split 1 3-channel image into 3 1-channel images</span></span><br><span class="line">cv::split(image1,planes);</span><br><span class="line"><span class="comment">// add to blue channel</span></span><br><span class="line">planes[<span class="number">0</span>]+= image2;		<span class="comment">//planes[0],通道1；planes[1],通道2；planes[2],通道3；</span></span><br><span class="line"><span class="comment">// merge the 3 1-channel images into 1 3-channel image</span></span><br><span class="line">cv::merge(planes,result);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Defining_regions_of_interest"><strong>Defining regions of interest</strong></h1><p>　　如果想把一张小图片往大图片上贴，由于大小尺寸不同，无法直接用<code>cv::add</code>,这时候就需要定义感兴趣区域(ROI, regions of interest).</p>
<h2 id="实现方法-1"><strong>实现方法</strong></h2><p>　　定义感兴趣区域，插入图像：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define image ROI</span></span><br><span class="line">cv::Mat imageROI;</span><br><span class="line">imageROI = image(cv::Rect(<span class="number">385</span>, <span class="number">270</span>, logo.cols, logo.rows));</span><br><span class="line"><span class="comment">// add logo to image</span></span><br><span class="line">cv::addWeighted(imageROI, <span class="number">1.0</span>, logo, <span class="number">0.3</span>, <span class="number">0.</span>, imageROI);</span><br></pre></td></tr></table></figure></p>
<p>　　我们知道<code>cv::Mat</code>赋值操作只是浅拷贝，他们共享一块内存，也就是说imageROI指向的就是原图片，改变imageROI，意味着改变原图像，从而实现插入。　但是在书上的图中我们看到，效果不明显，因为直接相加，可能像素值超过255，然后使其为255，这样就造成效果不明显，所以书上又提供了掩模来操作，直接替换原图像该位置的像素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define ROI</span></span><br><span class="line">imageROI = image(cv::Rect(<span class="number">385</span>, <span class="number">270</span>, logo.cols, logo.rows));</span><br><span class="line"><span class="comment">// load the mask (must be gray-level)</span></span><br><span class="line">cv::Mat mask = cv::imread(<span class="string">"logo.bmp"</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// copy to ROI with mask</span></span><br><span class="line">logo.copyTo(imageROI, mask);</span><br></pre></td></tr></table></figure>
<p>　　掩模的作用就是只处理原图像中对应掩模元素不为NULL的位置的元素。比如掩模(1, 1)处为NULL，那么原图像该位置就不处理，如果该位置不为NULL，那么原图像这个位置像素就处理。</p>
<h2 id="定义ROI的方法"><strong>定义ROI的方法</strong></h2><p>(1)上面已经给出一种方法了，使用<code>cv::Rect</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat imageROI;</span><br><span class="line">imageROI = image(cv::Rect(<span class="number">385</span>, <span class="number">270</span>, logo.cols, logo.rows));</span><br></pre></td></tr></table></figure></p>
<p>(2)这里介绍第二种方法,使用<code>cv::Range</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat imageROI = image(cv::Range(<span class="number">270</span>,<span class="number">270</span>+logo.rows), cv::Range(<span class="number">385</span>,<span class="number">385</span>+logo.cols));</span><br></pre></td></tr></table></figure></p>
<p><code>cv::Range</code>是指从起始索引到终止索引(不包含终止索引)的一段连续序列。<br>(3)第二种方法的扩展<br>创建原始图像特定行/列的ROI<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat imageROI = image.rowRange(start, end);	<span class="comment">//行</span></span><br><span class="line">cv::Mat imageROI = image.colRange(start, end);	<span class="comment">//列</span></span><br></pre></td></tr></table></figure></p>
<hr>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Computer-Vision/" rel="tag">#Computer Vision</a>
          
            <a href="/tags/OpenCV/" rel="tag">#OpenCV</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/10/26/151026-OpenCV-Manipulating-the-Pixels/" rel="next" title="OpenCV 学习笔记(2) Manipulating the Pixels (上)">
                <i class="fa fa-chevron-left"></i> OpenCV 学习笔记(2) Manipulating the Pixels (上)
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/10/28/151028-OpenCV-Processing-images-with-classes/" rel="prev" title="OpenCV 学习笔记(3) Processing images with classes">
                OpenCV 学习笔记(3) Processing images with classes <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2015/10/26/151026-OpenCV-Manipulating-the-pixels-2/"
           data-title="OpenCV 学习笔记(2) Manipulating the Pixels (下)" data-url="site:ocxsBlog.github.io/2015/10/26/151026-OpenCV-Manipulating-the-pixels-2/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/avatar.png"
               alt="Xusong Chen" />
          <p class="site-author-name" itemprop="name">Xusong Chen</p>
          <p class="site-description motion-element" itemprop="description">Welcome</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">36</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Writing_effcient_image_scanning_loops"><span class="nav-number">1.</span> <span class="nav-text">Writing effcient image scanning loops</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现方法"><span class="nav-number">1.1.</span> <span class="nav-text">实现方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenMP_and_TBB"><span class="nav-number">1.2.</span> <span class="nav-text">OpenMP and TBB</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Scanning_an_image_with_neighbor_access"><span class="nav-number">2.</span> <span class="nav-text">Scanning an image with neighbor access</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原始的指针操作"><span class="nav-number">2.1.</span> <span class="nav-text">原始的指针操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用filter2D_method"><span class="nav-number">2.2.</span> <span class="nav-text">使用filter2D method</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Performing_simple_image_arithmetic"><span class="nav-number">3.</span> <span class="nav-text">Performing simple image arithmetic</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的运算"><span class="nav-number">3.1.</span> <span class="nav-text">简单的运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Overloaded_image_operators"><span class="nav-number">3.2.</span> <span class="nav-text">Overloaded image operators</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Splitting_the_image_channels"><span class="nav-number">3.3.</span> <span class="nav-text">Splitting the image channels</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Defining_regions_of_interest"><span class="nav-number">4.</span> <span class="nav-text">Defining regions of interest</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现方法-1"><span class="nav-number">4.1.</span> <span class="nav-text">实现方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义ROI的方法"><span class="nav-number">4.2.</span> <span class="nav-text">定义ROI的方法</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xusong Chen</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ocxsblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
