<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Computer Vision,OpenCV," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="In this chapter, we will cover:


Detecting image contours with the Canny operator
Detecting lines in images with the Hough transform    （使用Hough变换检测直线）
Fitting a line to a set of points    （用直线拟合一组点）">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV 学习笔记(7) Extracting Lines,Contours and Components">
<meta property="og:url" content="site:ocxsBlog.github.io/2015/12/24/151224-extracting-lines-contours-and-components/index.html">
<meta property="og:site_name" content="Ocxs's blog">
<meta property="og:description" content="In this chapter, we will cover:


Detecting image contours with the Canny operator
Detecting lines in images with the Hough transform    （使用Hough变换检测直线）
Fitting a line to a set of points    （用直线拟合一组点）">
<meta property="og:image" content="site:ocxsBlog.github.io/\img\151224-1.png">
<meta property="og:image" content="site:ocxsBlog.github.io/\img\151224-2.jpg">
<meta property="og:image" content="site:ocxsBlog.github.io/\img\151224-3.png">
<meta property="og:updated_time" content="1970-01-01T00:00:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenCV 学习笔记(7) Extracting Lines,Contours and Components">
<meta name="twitter:description" content="In this chapter, we will cover:


Detecting image contours with the Canny operator
Detecting lines in images with the Hough transform    （使用Hough变换检测直线）
Fitting a line to a set of points    （用直线拟合一组点）">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> OpenCV 学习笔记(7) Extracting Lines,Contours and Components | Ocxs's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Ocxs's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">To be better</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                OpenCV 学习笔记(7) Extracting Lines,Contours and Components
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2015-12-24T19:02:34+08:00" content="2015-12-24">
              2015-12-24
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/24/151224-extracting-lines-contours-and-components/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/24/151224-extracting-lines-contours-and-components/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>In this chapter, we will cover:</p>
<blockquote>
<ul>
<li>Detecting image contours with the Canny operator</li>
<li>Detecting lines in images with the Hough transform    （使用Hough变换检测直线）</li>
<li>Fitting a line to a set of points    （用直线拟合一组点）</li>
<li>Extracting the components’ contours（提取连通区域的轮廓）</li>
<li>Computing components’ shape descriptors    </li>
</ul>
</blockquote>
<a id="more"></a>
<h1 id="使用Canny算子检测轮廓"><strong>使用Canny算子检测轮廓</strong></h1><h2 id="Canny的使用"><strong>Canny的使用</strong></h2><p>　　OpenCV中Canny算法的函数是<code>cv::Canny</code>，该算法需要指定两个阈值，调用如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat contours;</span><br><span class="line">cv::Canny(image, contours, <span class="number">125</span>, <span class="number">350</span>);	<span class="comment">//125: low threshold, 350: high threshold</span></span><br></pre></td></tr></table></figure></p>
<p>Read more <a href="http://docs.opencv.org/2.4.9/modules/imgproc/doc/feature_detection.html?highlight=canny#cv.Canny" target="_blank" rel="external">here</a>. Canny边缘检测的结果是轮廓用非零元素表示，书上为了方便打印，所以反转了颜色。</p>
<h2 id="theroy"><strong>theroy</strong></h2><p>　　参考<a href="https://en.wikipedia.org/wiki/Canny_edge_detector" target="_blank" rel="external">wikipedia</a>的解释，canny 边缘检测主要分为以下5个步骤:</p>
<blockquote>
<ul>
<li>Apply Gaussian filter to smooth the image in order to remove the noise</li>
<li>Find the intensity gradients of the image</li>
<li>Apply non-maximum suppression to get rid of spurious response to edge detection</li>
<li>Apply double threshold to determine potential edges</li>
<li>Track edge by hysteresis: Finalize the detection of edges by suppressing all the other edges that are weak and not connected to strong edges.</li>
</ul>
</blockquote>
<p>　　先用高斯滤波去噪，然后计算梯度(opencv中使用sobel算子实现)，利用non-maximum suppression(非极大值抑制)的方法得到精细的边缘(仅仅使用sobel算子处理后的结果不精细，会有需要聚集在一起的块，而非边缘，所以使用NMS来取局部最大值，NMS只保留局部最大值，其余的全部使其为0)，这时候得到的结果可能仍然包含噪声的边缘，所以使用double threshold进行修正，梯度值大于high threshold value的我们认为肯定是strong edge pixels，大于low threshold value且小于high threshold value的认为是weak edge pixels，小于low threshold value，就会被抑制，使其为0.但是weak edge pixels里可能仍然有噪点的边缘，所以使用Binary Large Object (BLOB) analysis，看weak edge pixel的八连通区域里是否有strong edge pixel，只要有一个，就认为这个weak edge pixel是边缘，应该保留，否则抑制为0.最后得到的结果就是canny边缘检测算法的结果。此外链接里还讲了canny算法的提高，这里不在叙述，有兴趣请自行查看。</p>
<p>　　其中书上也说了磁滞阈值化（hysteresis thresholding,就是需要两个阈值，一个高阈值，一个低阈值）之前，进行non-maximum suppression，所以canny能得到很薄的边缘，如果还是不理解，把sobel算子的结果跑出来和canny对比一下就会发现，sobel算子的结果比较粗，不精细。</p>
<hr>
<h1 id="使用Hough变换检测直线"><strong>使用Hough变换检测直线</strong></h1><p>　　Hough Transform是检测直线的经典算法，它最初只用于检测直线，被扩展后能够检测其他的简单结构，如圆等。</p>
<h2 id="Related_Work"><strong>Related Work</strong></h2><p>　　在Hough Transform中，直线常用下列方程表示：<br>$$p = x \cos \theta + y \sin \theta \tag{1} $$</p>
<p>　　　　　　　　　　　　　　　　<img src="\img\151224-1.png" alt="151224-1"><br>　　　　　　　　　        　　　　　　　　　　　　　　　<strong>图1</strong></p>
<p>　　如图1所示，参数$p$是直线(直线上的点)到图像原点（左上角）的最短距离（过原点做直线的垂线，该垂线就是最短距离），$\theta$是垂线绕x轴正方向转过的角度。$\theta$取值范围是$[0, \pi)$,$p$的最大值是图像的对角线长度，但也有可能是负值，下面说。<br>　　直线1的垂直线的角度$\theta$等于0，直线1也同时解释为何我们不用$y=kx+b$来表达直线，而采取极坐标系，因为这时候斜率$k$无穷大，无法表示，所以就换一种方式了；直线5的$\theta$等于$\pi /2$;直线3的$\theta$等于$\pi /4$；直线4的$\theta$约等于$0.7 \pi$。而直线2的$\theta$约等于$0.8 \pi$，大于135度，这时候$p$就是负值，在$\theta$取值范围在$[3\pi / 4, \pi)$时，可以把上述公式这样写成$y = -(\cos \theta / \sin \theta)x + p / \sin \theta $,因为图像的坐标系是向下为正，以左上角为原点，所以自然截矩$p / \sin \theta$是负值，其中$\sin \theta$在取值范围内是正数，所以p是负值。</p>
<h2 id="应用"><strong>应用</strong></h2><p>　　OpenCV中提供两种Hough变换的实现,基础版本是<code>cv::HoughLines</code>, 它要求的输入图像是八位单通道的二进制图像，但是即使你按照要求输入也行，函数会帮你改，非0的变为1；此外他的输出是一个向量$(p, \theta)$，通常保存在<code>vector</code>里面，具体见下面代码；参数<code>rho</code>就是移动步长，一般设为1；参数<code>theta</code>是转动角度，一般都是直线每转一度就算一次，看看该直线经过多少点，这样在区间$[0, \pi)$内我们都计算了一下，避免遗漏；参数<code>threshold</code>是阈值，我们前面在每个<code>rho</code>和<code>theta</code>下面就会计算该直线经过多少点，通过阈值来去除一些不满足要求的点，只有该直线上经过的点大于阈值所定数目时，我们才会认为他是直线，阈值怎么定，看实际情况吧。See more <a href="http://docs.opencv.org/2.4.9/modules/imgproc/doc/feature_detection.html#houghlines" target="_blank" rel="external">here</a>.</p>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [20151225]Opencv_chapter7.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stdafx.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawHoughLines</span><span class="params">(cv::Mat &amp;iamge, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Vec2f&gt; lines)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, lines.size());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; lines.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">float</span> rho = lines[i][<span class="number">0</span>], theta = lines[i][<span class="number">1</span>];</span><br><span class="line">		cv::Point pt1, pt2;</span><br><span class="line">		<span class="keyword">double</span>	a = cv::<span class="built_in">cos</span>(theta), b = cv::<span class="built_in">sin</span>(theta);</span><br><span class="line">		<span class="keyword">double</span> x0 = a * rho, y0 = b *rho;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"1 is %f, 2 is %f\n"</span>, <span class="number">1000</span> * (-b), <span class="number">1000</span> * (a));</span><br><span class="line">		pt1.x = cvRound(x0 + <span class="number">1000</span> * (-b));</span><br><span class="line">		pt1.y = cvRound(y0 + <span class="number">1000</span> * (a));</span><br><span class="line">		pt2.x = cvRound(x0 - <span class="number">1000</span> * (-b));</span><br><span class="line">		pt2.y = cvRound(y0 - <span class="number">1000</span> * (a));</span><br><span class="line">		cv::line(iamge, pt1, pt2, cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>, CV_AA);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawHoughLines2</span><span class="params">(cv::Mat &amp;image, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Vec2f&gt; lines)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; lines.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">float</span> rho = lines[i][<span class="number">0</span>], theta = lines[i][<span class="number">1</span>];</span><br><span class="line">		cv::<span class="function">Point <span class="title">pt1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span>, <span class="title">pt2</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		pt1.x = rho / cv::<span class="built_in">cos</span>(theta);	pt1.y = <span class="number">0</span>;</span><br><span class="line">		pt2.x = (rho - image.rows * cv::<span class="built_in">sin</span>(theta)) / cv::<span class="built_in">cos</span>(theta);	pt2.y = image.rows;</span><br><span class="line"><span class="comment">// 		if (theta &lt; CV_PI / 4 || theta &gt; 3 * CV_PI / 4)</span></span><br><span class="line"><span class="comment">// 		&#123;</span></span><br><span class="line"><span class="comment">// 			pt1.x = rho / cv::cos(theta);	pt1.y = 0;</span></span><br><span class="line"><span class="comment">// 			pt2.x = (rho - image.rows * cv::sin(theta)) / cv::cos(theta);	pt2.y = image.rows;</span></span><br><span class="line"><span class="comment">// 		&#125;</span></span><br><span class="line"><span class="comment">// 		else</span></span><br><span class="line"><span class="comment">// 		&#123;</span></span><br><span class="line"><span class="comment">// 			pt1.x = 0;		pt1.y = rho / cv::sin(theta);</span></span><br><span class="line"><span class="comment">// 			pt2.x = image.cols;		pt2.y = (rho - image.cols * cv::cos(theta)) / cv::sin(theta);</span></span><br><span class="line"><span class="comment">// 		&#125;</span></span><br><span class="line">		cv::line(image, pt1, pt2, cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>, CV_AA);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	cv::Mat image = cv::imread(<span class="string">"../../resource2/road.jpg"</span>);</span><br><span class="line">	cv::Mat imageCopy = image.clone();</span><br><span class="line"></span><br><span class="line">	cv::Mat edge;</span><br><span class="line">	cv::Canny(imageCopy, edge, <span class="number">125</span>, <span class="number">350</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	cv::Mat dx, dy;</span><br><span class="line">	cv::Sobel(imageCopy, dx, imageCopy.depth(), 1, 0, 3);</span><br><span class="line">	cv::Sobel(imageCopy, dy, imageCopy.depth(), 0, 1, 3);</span><br><span class="line">	cv::threshold(dx, dx, 128, 255, CV_THRESH_BINARY_INV);</span><br><span class="line">	cv::threshold(dy, dy, 128, 255, CV_THRESH_BINARY_INV);</span><br><span class="line">*/</span></span><br><span class="line"><span class="comment">//	cv::imshow("dx", dx);</span></span><br><span class="line"><span class="comment">//	cv::imshow("dy", dy);</span></span><br><span class="line"></span><br><span class="line">	cv::Mat result;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Vec2f&gt; lines;</span><br><span class="line">	cv::HoughLines(edge, lines, <span class="number">1</span>, CV_PI / <span class="number">180</span>, <span class="number">80</span>);</span><br><span class="line">	DrawHoughLines(imageCopy, lines);</span><br><span class="line">	DrawHoughLines2(imageCopy, lines);</span><br><span class="line"></span><br><span class="line">	cv::Mat test;</span><br><span class="line">	test = cv::Mat::zeros(<span class="number">500</span>, <span class="number">500</span>, CV_8UC3);</span><br><span class="line">	cv::<span class="function">Point <span class="title">pt1</span><span class="params">(<span class="number">0</span>, <span class="number">552</span>)</span>, <span class="title">pt2</span><span class="params">(<span class="number">500</span>, <span class="number">203</span>)</span></span>;</span><br><span class="line">	cv::line(test, pt1, pt2, cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>, CV_AA);</span><br><span class="line"></span><br><span class="line"><span class="comment">//	cv::imshow("result", result);</span></span><br><span class="line">	cv::imshow(<span class="string">"edge"</span>, edge);</span><br><span class="line">	cv::imshow(<span class="string">"iamgeCopy"</span>, imageCopy);</span><br><span class="line">	cv::imshow(<span class="string">"test"</span>, test);</span><br><span class="line"></span><br><span class="line">	cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　进行边缘检测后使用Hough变换做直线检测，最后调用画线函数将其画出来，这里给了两种画线的方式。<br>　　第一种是OpenCV自带的demo里的方式，可能刚开始看到后有点不理解，为何搞个1000，如果不理解可以看<a href="http://stackoverflow.com/questions/18782873/houghlines-transform-in-opencv" target="_blank" rel="external">这里</a>。<br>　　第二种方法是书上的，是分开角度来算，我测试了一下，发现完全没有必要，你把<code>if</code>里面的或者<code>else</code>里面的任意一个单独拎出来都可以计算出结果，刚开始我还比较疑惑，比如对于一个500*500的图片，如果给一个点$(0,525)$,一个点$(550,203)$,那这样岂不是越界了，点都不在图像范围内，后来发现OpenCV提供的画线函数<code>cv::line</code>可以hold住，只要你提供两个点就ok，正事因为这个函数的强大，所以就不用像书上那样麻烦，其实书上搞的这个东西说解决近似水平或者近似竖直的直线，我觉得这个好像是有点…….因为如果一条直线经过图像的最后一行，最后一列，按照书上的意思他的这个<code>if..else</code>是hold不住的，但是其实没问题，没问题是因为<code>cv::line</code>函数的强大，和他的这个<code>if..else</code>是没有关系的。<strong>当然这是我的观点，难免会有边界条件等没考虑到，如果你发现错误，请予以指正，不胜感激</strong>。也许你可能不理解这句代码<code>pt2.x = (rho - image.rows * cv::sin(theta)) / cv::cos(theta);</code>,但是如果这样写或许就会明白了，<code>pt2.x = rho/cv::cos(theta) - image.rows * cv::sin(theta)/cv::cos(theta);</code>如图2所示：</p>
<p><img src="\img\151224-2.jpg" alt="151224-1"><br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　<strong>图2</strong></p>
<p>另外那个同理，可以自己画画看，推倒一下。</p>
<p>　　然而由于基本的Hough Transform可能由于意外的像素排列或者多条直线经过同一组像素,有误检，所以提出概率Hough变换(Probabilistic Hough Transform),对应的函数是<code>cv::HoughLinesP</code>,大部分参数一致，不同的是输出为$(x_1, y_1, x_2, y_2)$,$(x_1, y_1)$和$(x_2, y_2)$是线的两个端点坐标；此外添加了两个阈值，一个<code>minLineLength</code>,表示检测到的直线长度小于该阈值则被out，一个<code>maxLineGap</code>，表示在同一直线上点之间的距离不能超过这个值，这样一条直线同样是经过十个点，如果这十个点之间的距离大于maxLineGap我们就认为这并不是一条直线，如果小于则认为是直线。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Vec4i&gt; lines;</span><br><span class="line">cv::HoughLinesP(edge, lines, <span class="number">1</span>, CV_PI / <span class="number">180</span>, <span class="number">80</span>, <span class="number">30</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; lines.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">	cv::line(imageCopy, cv::Point(lines[i][<span class="number">0</span>], lines[i][<span class="number">1</span>]), cv::Point(lines[i][<span class="number">2</span>], lines[i][<span class="number">3</span>]), cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, lines.size());</span><br></pre></td></tr></table></figure></p>
<h2 id="Theory"><strong>Theory</strong></h2><p>Hough Transform用来检测直线，这里可以参考<a href="https://en.wikipedia.org/wiki/Hough_transform" target="_blank" rel="external">wikipedia里的资料</a> ，可以直接看Example部分，我将链接里的图引用过来如图3所示：<br><img src="\img\151224-3.png" alt="151224-3.png"><br><strong>图3</strong><br>在图3中我们可以看出，它在每一个点(在该图中一共三个，在二值图像中，计算每一个点)上每次转动30度来计算距离(我们在上面的代码中中计算是以每次转动1度来计算距离，防止有遗漏，这里仅作示例，所以转动30度)，这样的话，我们就可以用一个矩阵来存储这些数据，如果有相同的角度和距离就对其加1，这样最后看矩阵里的值，我们定义一个阈值，超过该阈值就认为这是一条直线即可。图3中可以看出在60度，距离为80左右时，累加次数我们可以算做3(不要钻牛角尖，81.2,80.5,80.6都可以近似为80了，毕竟其他数据差距比这大多了)，那我们就认为该直线经过这三个点，链接里下面的那个图(三条曲线的交点)也说明这一点。<br>引用书上的话说：Hough Transform的目的是找到二值图像中经过足够数量的点的所有直线，它分析每一个点（<strong>注意不是分析每一个像素点，从代码中我们可以看出输入的是边缘图像，即二值图像，我们可以理解成我们要检测这些边缘中有没有直线边缘，所以这里的每一个点指的是边缘上的点，而非图像中每一个像素点，所以需要逐行扫描看哪些是边缘点，一般情况下边缘点都是用非零像素标记，而HoughLines函数也是默认非零像素点才是边缘点，如果使用threshold函数把像素值颜色反转，就会造成结果很大差别，因为本来的零像素值点变成了非零像素了，有兴趣的试试</strong>，并识别出所有可能经过它的直线。当同一条直线穿过许多点时，就可以认为检测到这条直线了。Hough transform使用二维的累加器来统计特定的直线被识别多少次，累加器的大小由$(p, \theta)$决定，比如定义步长$p=1$和$\theta = \pi/180$，在一个图像的对角线为200的情况下，那么这个累加器的尺寸就是$200*180$（对角线是距离原点最远的了，所以是200），然后我们就统计每一个点转动180次的结果，然后在累加器的对应位置加1，在统计完很多次以后，累加器中肯定有的位置的值比较大，有的比较小，值比较大的位置，他的坐标就是$(p, \theta)$,也就是说我们只要在这累加器中找到比规定阈值大的，就能得到相应的$(p, \theta)$，那自然直线就得到了。这就是Hough变换的原理。<br>此外书上也给出了阈值比较小时，就会检测到更多的直线，然而这些都是误检，所以看出阈值很重要。<br>概率Hough Transform在上面基本的算法中增加了少许改动。首先不再是逐行扫描图像而是随机挑选像素点。一旦累加器中某一项达到给定的最小值(参数threshold)，就扫描沿着对应直线的像素并移出所有经过的点（即便他们并没有被计算过）。这次扫描决定了接受线段的长度。为此，定义了两个额外的参数，之前已经介绍过了。额外的算法步骤增加了复杂度，但是由于参与投票的点减少得到部分的补偿。</p>
<h2 id="Circles_Hough_Transform(CHT)"><strong>Circles Hough Transform(CHT)</strong></h2><h3 id="Theory-1"><strong>Theory</strong></h3><p>　　可以参考<a href="https://en.wikipedia.org/wiki/Circle_Hough_Transform" target="_blank" rel="external">Circles Hough Transform</a>.在二维空间里，圆的方程表示为如下形式：<br>$$(x-a)^2 + (y-b)^2 = r^2  \tag{2} $$<br>　　$(a,b)$是圆心位置，$r$是半径，不像直线方程，在二维参数空间下就可以表示(即二维矩阵就能hold住，$(r, \theta)$),这里未知的参数是3个，所以需要三维的参数空间才行，然而三维参数空间想找局部最大值很难，不像二维那么好找（找局部最大值就是为了找到圆，对应局部最大值的三个坐标就能确定一个圆，类似前面直线检测里对应局部最大值的两个坐标就能确定一条直线）。那既然三维空间不好找，大家就折中一下，换个方式找，怎么弄的，先不管待会说，先说怎么在半径确定的情况下怎么找圆心。<br>　　根据数学知识，如果同一平面上的三个点共圆的画，假设该圆半径为$r$,然后以这三个点为圆心画半径为$r$的圆，则画出来的三个圆的交点即为这个三个点的圆心。那这样就好办了，比如一个平面上有10个点，其中九个点共圆，一个点在其他位置，那么在我们已知半径为$r$的情况下，我们就在每个点上画半径为$r$的圆，在敲代码时，这个平面肯定是有限大的，可以用个二维数组（矩阵）来存储，然后在每个点上画圆时，圆上没经过一处，我们就在那个位置累加1，这个最后画完之后，角点出的累计值就为9，那么最后我们在这个二维数组里找局部最大值（超过某个阈值）还是可以比较快的找到的（这个过程和直线检测还是蛮相似的）。<br>　　那么新的问题来了，上面所说的都是已知半径，那么如果不知道半径 怎么办，那就一个个试，比如图像是$600*600$的，那么圆的半径肯定不会超过300了，那就可以从$[1, 300]$这个范围里找，实际OpenCV里的函数提供了参数，让你自己定义可能的半径范围。</p>
<h3 id="应用-1"><strong>应用</strong></h3><p>　　OpenCV里提供的函数是<code>cv::HoughCircles</code>, see more <a href="http://docs.opencv.org/2.4.9/modules/imgproc/doc/feature_detection.html#houghcircles" target="_blank" rel="external">here</a> in detail.<br>　　输入和<code>cv::HoughLines</code>一样，都是边缘检测后的边缘图像（一般多用<code>cv::Canny</code>）；输出是一个三维向量$(x,y,r)$,即圆心坐标和半径；<code>Method</code>参数一般多用<code>CV_HOUGH_GRADIENT</code>,<strong><code>dp</code>参数我暂时不太理解，但是在Stackoverflow上写了个<a href="http://stackoverflow.com/questions/34706092/how-exactly-does-dp-parameter-in-cvhoughcircles-work" target="_blank" rel="external">提问</a>，等待大神回答</strong>，大神已回答，可以参考，底下有我一点自己的理解，如有错误，恳请指正。<code>minDist</code>参数就是你检测的圆的圆心之间的最小距离，所有检测出来的圆，圆心小于该距离的会被reject。<code>param1</code> 参数就是之前Canny边缘检测里面较大的那个参数，他们两值一样。<code>param2</code> 参数就是阈值，检测到圆的投票数，低于该阈值的被reject。<code>minRadius</code> 和<code>maxRadius</code> 就是圆的最小半径和最大半径，按照前面的解释，在这个范围里找。<br>　　关于dp参数的理解，根据上面链接里大神的讲解，dp参数的作用是控制累加器的size，dp越大，累加器的size越小，即dp=2，累加器的宽高只有图像的一半，dp=3，累加器的宽高只有图像的三分之一。我之前一直不理解当累加器的大小与图像不一样时是怎么在hough space下投票的，根据大神说的，相近的像素被合并，这样我就懂了。前面说了，我们在边缘点上画圆，然后圆上经过的点都会被vote，那时候刚好一个像素点对应矩阵（hough space）里的一个位置，我懂只要在对应位置加1即可，但是累加器缩小以后，怎么办呢？其实可以这样理解，还是在跟图像一样大小的累加器里投票，然后把这个累加器按照dp参数的大小来缩小，这样比如本来某几个邻近位置的投票数就会被合并到一起，这样导致得不到非常精确的圆，但是这个投票是robust，就是说虽然得不到非常精确的，但是我能保证我检测到的这个圆很大很大可能性是存在的，而且和真实的圆很接近。大神还补充了OpenCV里的实现是用梯度来算的，不是用标准hough变换来做的，如何使用梯度来算，可以参考<a href="http://www.opencv.org.cn/forum.php?mod=viewthread&amp;tid=34096" target="_blank" rel="external">这个文章</a>，讲的挺好。补充一下，在这个链接里可以看到使用梯度计算时，有时因为误差，导致同一个圆上的点映射的圆心不在同一个位置，但是比较接近，这时候如果按照前面说的dp参数的作用，把dp设为2，或者更大的数，那么累加器中相近的位置被合并，那么是不是就可以确定一个唯一的圆心了，是不是，如果不合并即dp=1，那么可能vote数量没有超过阈值而导致检测不出来圆或者一下子出来好几个圆。</p>
<p>代码我是直接把文档里的拷贝过来了，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Mat img, gray;</span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">2</span> &amp;&amp; !(img=imread(argv[<span class="number">1</span>], <span class="number">1</span>)).data)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    cvtColor(img, gray, CV_BGR2GRAY);</span><br><span class="line">    <span class="comment">// smooth it, otherwise a lot of false circles may be detected</span></span><br><span class="line">    GaussianBlur( gray, gray, Size(<span class="number">9</span>, <span class="number">9</span>), <span class="number">2</span>, <span class="number">2</span> );		<span class="comment">//先降噪，减少噪点的影响</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Vec3f&gt; circles;				<span class="comment">//注意，这里必须是Vec3f</span></span><br><span class="line">    HoughCircles(gray, circles, CV_HOUGH_GRADIENT,</span><br><span class="line">                 <span class="number">2</span>, gray-&gt;rows/<span class="number">4</span>, <span class="number">200</span>, <span class="number">100</span> );</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; circles.size(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="function">Point <span class="title">center</span><span class="params">(cvRound(circles[i][<span class="number">0</span>])</span>, <span class="title">cvRound</span><span class="params">(circles[i][<span class="number">1</span>])</span>)</span>;</span><br><span class="line">         <span class="keyword">int</span> radius = cvRound(circles[i][<span class="number">2</span>]);</span><br><span class="line">         <span class="comment">// draw the circle center</span></span><br><span class="line">         circle( img, center, <span class="number">3</span>, Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), -<span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span> );</span><br><span class="line">         <span class="comment">// draw the circle outline</span></span><br><span class="line">         circle( img, center, radius, Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">3</span>, <span class="number">8</span>, <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    namedWindow( <span class="string">"circles"</span>, <span class="number">1</span> );</span><br><span class="line">    imshow( <span class="string">"circles"</span>, img );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="广义hough变换"><strong>广义hough变换</strong></h2><p>伯克利的<a href="http://web.eecs.umich.edu/~silvio/teaching/EECS598/lectures/lecture10_3.pdf" target="_blank" rel="external">讲义</a>关于Hough 变换的，其中广义hough变换(Generalised Hough transform,GHT)说的比较浅显易懂，<a href="https://en.wikipedia.org/wiki/Generalised_Hough_transform" target="_blank" rel="external">wikipedia</a>里的讲的也不错.</p>
<hr>
<h1 id="Fitting_a_line_to_a_set_of_points"><strong>Fitting a line to a set of points</strong></h1><p>本节主要讲给定一组点，如何找出那条最贴近这组点的直线（有点像最小二乘法）。</p>
<h2 id="实现方法"><strong>实现方法</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//points可以是一组二维或三维的点集，例std::Vector&lt;cv::Point&gt;points;</span></span><br><span class="line">cv::Vec4f line;</span><br><span class="line">cv::fitLine(cv::Mat(points),line,</span><br><span class="line">CV_DIST_L2, <span class="comment">// distance type</span></span><br><span class="line"><span class="number">0</span>, <span class="comment">// not used with L2 distance</span></span><br><span class="line"><span class="number">0.01</span>,<span class="number">0.01</span>); <span class="comment">// accuracy</span></span><br></pre></td></tr></table></figure>
<p><code>cv::fitLine</code>的各个参数含义见<a href="http://docs.opencv.org/2.4.9/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html?highlight=fitline#cv.FitLine" target="_blank" rel="external">文档</a>.其中输出<code>line</code>为<code>(vx, vy, x0, y0)</code>（二维）或<code>(vx, vy, vz, x0, y0, z0)</code>（三维），<code>(vx, vy)</code>是一组与拟合直线平行的向量，相当于提供斜率（即vy/vk）不过他们的绝对值应该都是小于1的，<code>(x0, y0)</code>就是拟合直线上的一点。<br>想要将该直线画出来，引用书上的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x0= line[<span class="number">2</span>]; <span class="comment">// a point on the line</span></span><br><span class="line"><span class="keyword">int</span> y0= line[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> x1= x0-<span class="number">200</span>*line[<span class="number">0</span>]; <span class="comment">// add a vector of length 200</span></span><br><span class="line"><span class="keyword">int</span> y1= y0-<span class="number">200</span>*line[<span class="number">1</span>]; <span class="comment">// using the unit vector</span></span><br><span class="line">image= cv::imread(<span class="string">"../road.jpg"</span>,<span class="number">0</span>);</span><br><span class="line">cv::line(image,cv::Point(x0,y0),cv::Point(x1,y1),</span><br><span class="line">cv::Scalar(<span class="number">0</span>),<span class="number">3</span>);</span><br><span class="line">```	</span><br><span class="line">画出来的方法很多，书上举例，将 直线的长度定成<span class="number">200</span>。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">## **实现原理**</span></span><br><span class="line">直线拟合在`fitLine`函数中，有多个距离函数可供选用，最快的就是欧式距离（Euclidean distance），即参数`CV_DIST_L2`。该参数对应的是标准的最小二乘法。可以参考文档链接或者[M-estimator](https:<span class="comment">//en.wikipedia.org/wiki/M-estimator)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">## **椭圆拟合**</span></span><br><span class="line">```cpp</span><br><span class="line">cv::RotatedRect rrect= cv::fitEllipse(cv::Mat(points));</span><br><span class="line">cv::ellipse(image,rrect,cv::Scalar(<span class="number">0</span>));</span><br></pre></td></tr></table></figure></p>
<p><code>cv::ellipse</code>就能画出这个拟合后的椭圆了。其中返回的矩形的内切椭圆就是拟合的椭圆。</p>
<hr>
<h1 id="Extracting_the_components’_contours"><strong>Extracting the components’ contours</strong></h1><h2 id="实现方法-1"><strong>实现方法</strong></h2><p>如何提取连通域，OpenCV给出的实现函数<code>cv::findContours</code>，可参考<a href="http://docs.opencv.org/2.4.9/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html?highlight=findcontour#cv.FindContours" target="_blank" rel="external">文档</a>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point&gt; &gt; contours;</span><br><span class="line">cv::findContours(image, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"contours.size()"</span> &lt;&lt; contours.size() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">cv::<span class="function">Mat <span class="title">result</span><span class="params">(image.size()</span>, CV_8U, cv::<span class="title">Scalar</span><span class="params">(<span class="number">255</span>)</span>)</span>;</span><br><span class="line">cv::drawContours(result, contours, -<span class="number">1</span>, cv::Scalar(<span class="number">0</span>), <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>移出过长或过短的轮廓代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cmin = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> cmax = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point&gt; &gt;::const_iterator itc = contours.begin();</span><br><span class="line"><span class="keyword">while</span> (itc != contours.end())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (itc-&gt;size() &lt; cmin || itc-&gt;size() &gt; cmax)</span><br><span class="line">	&#123;</span><br><span class="line">		itc = contours.erase(itc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		++itc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将这段代码加在<code>cv::drawContours</code>前面即可。这是在物体检测中，我们知道先验知识（比如知道物体的大小），通过去掉一些较小的或者较大的轮廓达到识别出感兴趣的物体。<br><code>cv::findContours</code>的参数<code>mode</code>：</p>
<ul>
<li>CV_RETR_EXTERNAL 只取外轮廓，忽略孔洞。文档里的hierarchy[i][2]=hierarchy[i][3]=-1，代表没有父轮廓和子轮廓，因为孔洞的轮廓相当于外轮廓的儿子，现在只取外轮廓，自然就没有子轮廓，没有子轮廓，也就没有父轮廓了。</li>
<li>CV_RETR_LIST 遍历所有轮廓，忽略轮廓之间的关系（如父子关系，前后关系（前后关系我翻译的不恰当，英文是previous和next））</li>
<li>CV_RETR_CCOMP 遍历所有的轮廓，但是所有轮廓的关系只有两层（种）。顶层关系中，包含的是外轮廓，第二层关系中，是外轮廓中的孔洞。如果 孔洞中还有孔洞，将其加入顶层中。依次类推，孔洞中孔洞中孔洞，应该就是第二层中。（个人理解）</li>
<li>CV_RETR_TREE  用树结构来遍历所有轮廓，外轮廓是根节点，孔洞是其子节点，孔洞的孔洞是其子节点的子节点，层次关系不像上面只有2层。<br><code>cv::findContours</code>的参数<code>method</code>：</li>
<li>CV_CHAIN_APPROX_NONE 存储轮廓上所有的点，其中任意两点(x1,y1) and (x2,y2)，他们遵循 max(abs(x1-x2),abs(y2-y1))==1这个规则.</li>
<li>CV_CHAIN_APPROX_SIMPLE 该参数适用与存储 特殊图像的轮廓点，比如矩形（其中两条边和x轴垂直的那种矩形，而不是斜着的矩形，个人理解，原文有个up-right），只需要存储四个顶点即可，而不用像上面那样存储所有的点，节省空间</li>
<li>CV_CHAIN_APPROX_TC89_L1,CV_CHAIN_APPROX_TC89_KCOS 使用teh-Chinl chain 近似算法。See <a href="http://docs.opencv.org/2.4.9/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html?highlight=findcontour#tehchin89" target="_blank" rel="external">TehChin89</a> for details.</li>
</ul>
<hr>
<h1 id="**"><em>**</em></h1>
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Computer-Vision/" rel="tag">#Computer Vision</a>
          
            <a href="/tags/OpenCV/" rel="tag">#OpenCV</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/12/11/151211-hexo-mistakes/" rel="next" title="Hexo渲染Markdown文件以及Latex代码出现错误的解决方案">
                <i class="fa fa-chevron-left"></i> Hexo渲染Markdown文件以及Latex代码出现错误的解决方案
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/03/02/160303-SML01/" rel="prev" title="统计学习理论学习笔记（一）">
                统计学习理论学习笔记（一） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2015/12/24/151224-extracting-lines-contours-and-components/"
           data-title="OpenCV 学习笔记(7) Extracting Lines,Contours and Components" data-url="site:ocxsBlog.github.io/2015/12/24/151224-extracting-lines-contours-and-components/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/avatar.png"
               alt="Xusong Chen" />
          <p class="site-author-name" itemprop="name">Xusong Chen</p>
          <p class="site-description motion-element" itemprop="description">Welcome</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">36</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#使用Canny算子检测轮廓"><span class="nav-number">1.</span> <span class="nav-text">使用Canny算子检测轮廓</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Canny的使用"><span class="nav-number">1.1.</span> <span class="nav-text">Canny的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#theroy"><span class="nav-number">1.2.</span> <span class="nav-text">theroy</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用Hough变换检测直线"><span class="nav-number">2.</span> <span class="nav-text">使用Hough变换检测直线</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Related_Work"><span class="nav-number">2.1.</span> <span class="nav-text">Related Work</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用"><span class="nav-number">2.2.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Theory"><span class="nav-number">2.3.</span> <span class="nav-text">Theory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Circles_Hough_Transform(CHT)"><span class="nav-number">2.4.</span> <span class="nav-text">Circles Hough Transform(CHT)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory-1"><span class="nav-number">2.4.1.</span> <span class="nav-text">Theory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#广义hough变换"><span class="nav-number">2.5.</span> <span class="nav-text">广义hough变换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fitting_a_line_to_a_set_of_points"><span class="nav-number">3.</span> <span class="nav-text">Fitting a line to a set of points</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现方法"><span class="nav-number">3.1.</span> <span class="nav-text">实现方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Extracting_the_components’_contours"><span class="nav-number">4.</span> <span class="nav-text">Extracting the components’ contours</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现方法-1"><span class="nav-number">4.1.</span> <span class="nav-text">实现方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#**"><span class="nav-number">5.</span> <span class="nav-text">**</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xusong Chen</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ocxsblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
